# **第一周作业**

## ***固定作业***

### **1.本周培训总结**
- ### 链表

  #### 链表基础概念

  - **定义**：链表是一种数据结构，它由一系列节点组成，每个节点都包含数据部分和指向下一个节点的指针。
  - **节点**：链表中的每个元素称为节点，节点通常包含数据域和指针域。
  - **基本操作**：链表的基本操作包括遍历、插入、删除和查找等。

  #### 链表的分类

  1. **静态链表**：
     - **定义**：静态链表是用数组实现的链表，数组的每个元素包含数据域和指针域（通常通过下标来模拟指针）。
     - **优缺点**：静态链表简单易懂，但空间利用率不高，因为需要预先分配固定大小的数组。
     - **应用场景**：适用于数据量较小或固定的场景。

  2. **动态链表**：
     - **定义**：动态链表是通过动态分配内存来实现的链表，每个节点在需要时动态分配。
     - **建立过程**：
       - 定义节点结构体，包含数据域和指针域。
       - 使用malloc或new等函数动态分配内存给新节点。
       - 初始化节点的数据域和指针域。
     - **插入操作**：在链表的指定位置插入新节点，需要调整相关节点的指针。
     - **删除操作**：从链表中删除指定节点，并释放其占用的内存。
     - **读取操作**：遍历链表，查找并读取指定节点的数据。
     - **特性**：动态链表灵活性强，可以动态调整大小，但管理内存较为复杂。
     - **应用场景**：适用于数据量较大或需要频繁插入和删除的场景。

  3. **循环链表**：
     - **定义**：循环链表是一种特殊的链表，其最后一个节点的指针指向第一个节点，形成一个闭环。
     - **特性**：循环链表没有明确的起点和终点，可以从任意节点开始遍历整个链表。
     - **应用场景**：适用于需要循环遍历的场景，如约瑟夫环问题。

  4. **双向链表**：
     - **定义**：双向链表是每个节点都有两个指针域，分别指向前一个节点和后一个节点。
     - **特性**：双向链表支持双向遍历，可以方便地访问前一个节点和后一个节点。
     - **应用场景**：适用于需要双向遍历或频繁插入和删除的场景。

- ### **定时器**

  #### **定时器基础**：

  - 介绍了TIM（timer）定时器的基本概念及其类型。

  #### 中断机制：

  - 阐述了定时器定时产生中断的原因。
  - 说明了如何实现以1秒为周期的中断。

  #### **PWM技术**：

  - 提供了PWM（脉宽调制）的简介。
  - 展示了PWM的基本结构。

  #### **输入捕获与编码器接口**：

  - 介绍了输入捕获的基本结构。
  - 描述了编码器接口，包括正交编码器的概念及其基本结构。

  这些内容系统地概述了定时器和PWM技术的关键方面，为深入理解这些概念提供了清晰的框架。

- ### **通信协议**

  STM32通信协议涉及多种通信方式和接口，这些协议使得STM32微控制器能够与其他设备或系统进行数据传输和交换。以下是STM32通信协议的一些简要介绍：

  ###  USART/UART

  * **定义**：USART是STM32中常用的串口通信协议。
  * **特点**：USART支持同步和异步通信，而UART仅支持异步通信。它们通常用于点对点通信，具有两个主要引脚：RX（接收）和TX（发送）。
  * **应用**：适用于低速到中速的数据传输，如与电脑、其他单片机或外设模块进行通信。

  ###  SPI

  * **定义**：SPI是一种高速、全双工、同步的通信协议。
  * **特点**：SPI使用四根线进行通信：MOSI（主机输出从机输入）、MISO（主机输入从机输出）、SCLK（时钟）和CS（片选）。它允许一个主设备与多个从设备进行通信。
  * **应用**：常用于微控制器与外围设备（如传感器、存储器、A/D转换器等）之间的连接。

  ###  I2C

  * **定义**：I2C是一种多主机、同步通信协议。
  * **特点**：I2C仅使用两根线进行通信：SCL（时钟）和SDA（数据）。它支持多设备连接，通过设备地址进行区分。
  * **应用**：广泛应用于低速外设连接，如传感器、EEPROM等。

  ###  CAN

  * **定义**：CAN是一种用于实时应用的串行通信协议。
  * **特点**：CAN具有高可靠性和错误检测能力，支持多主通信。它使用两根差分线（CAN_H和CAN_L）进行数据传输。
  * **应用**：常用于汽车、工业自动化等领域，用于设备之间的实时数据传输。

  <!--具体的通信协议要自己去看网课学习，了解操作原理-->

### 2.本周自己学习的内容

##### AD模数转换

##### DMA直接存储器读取

### 3.下周的规划

##### 完成本周培训内容

##### 学习STM32的12节内容



## *额外作业*

#### 1.使用定时器实现以1s为周期的LED流水灯闪烁的效果

**代码部分**

```c
#include "stm32f10x.h"  // Device header

uint32_t TimerCount = 0;  // 定时器计数

void Delay_ms(uint32_t ms)
{
    TimerCount = 0;  // 重置计时器计数
    while (TimerCount < ms);  // 等待计数达到指定的延时时间
}

// 定时器2中断处理程序
void TIM2_IRQHandler(void)
{
    if (TIM_GetITStatus(TIM2, TIM_IT_Update) != RESET)  // 检查是否是更新中断
    {
        TIM_ClearITPendingBit(TIM2, TIM_IT_Update);  // 清除中断标志
        TimerCount++;  // 增加计数
    }
}

int main(void)
{
    // 打开GPIOA时钟
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
    
    GPIO_InitTypeDef GPIO_InitStructure;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_All
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);

    Timer_Init();

    while (1)
    {
        GPIO_Write(GPIOA, ~(0x0001)); 
        Delay_ms(100); 

        GPIO_Write(GPIOA, ~(0x0002)); 
        Delay_ms(100);  

        GPIO_Write(GPIOA, ~(0x0004)); 
        Delay_ms(100);  

        GPIO_Write(GPIOA, ~(0x0008)); 
        Delay_ms(100);  

        GPIO_Write(GPIOA, ~(0x0010)); 
        Delay_ms(100);  

        GPIO_Write(GPIOA, ~(0x0020));
        Delay_ms(100);  

        GPIO_Write(GPIOA, ~(0x0040)); 
        Delay_ms(100);  

        GPIO_Write(GPIOA, ~(0x0080)); 
        Delay_ms(100);  
    }
}

```



#### 2.使用USART串口向单片机发送数据包并在oled屏幕上显示，在单片机收到数据包后向电脑发送字符串＂xiaoping＂

**实现部分**

![屏幕截图 2024-11-04 120312](D:\GDUT\小平\24秋季培训\第二周培训\屏幕截图 2024-11-04 120312.png)



**代码部分**

```c
#include "stm32f10x.h"                  // Device header
#include "Delay.h"
#include "OLED.h"
#include "Serial.h"
#include "string.h"

int main(void)
{
	/*模块初始化*/
	OLED_Init();				
	Serial_Init();		
	
	/*显示静态字符串*/
	OLED_ShowString(1, 1, "TxPacket:");
	OLED_ShowString(3, 1, "RxPacket:");
	
	while (1)
	{
		if (Serial_RxFlag == 1)		//如果接收到数据包
		{
			OLED_ShowString(4, 1, "                ");
			OLED_ShowString(4, 1, Serial_RxPacket);				//OLED清除指定位置，并显示接收到的数据包
			
			     if(strcmp(Serial_RxPacket,"Hello world!")==0)//发送hello world数据包
			  {
			  Serial_SendString("xiaoping\r\n");
			  OLED_ShowString(2, 1, "                ");
	        	OLED_ShowString(2,1,"xiaoping");

			  }
		      else
			  {
			  Serial_SendString("unknow command\r\n");

			  }
			
			Serial_RxFlag = 0;			//处理完成后，需要将接收数据包标志位清零，否则将无法接收后续数据包
		}
	}
}

```

